# -*- coding: utf-8 -*-
"""
Interaction with a PACS to get data. Use fetch() per dataset, or get_from_list()
for an input text file of patient/exam IDs.

Main Functions
--------------

fetch : used the old style patientID/examID inherited from the old
    database; calls query and get
get_entity : used by the GUI and works on objects returned from SQL
    queries of the biomatrix. Calls the get_* functions, and can
    define the directory structure for the resulting data
anon, anon_query, recursive_anonymise : strip patient names from
    the results file of a PACS query and from DICOM files. Note that
    other unique identifiers and names in free text fields are not
    accounted for.
"""
import shlex, subprocess, os
from fetch_data import sql_run
from prog.util.logs import set_logger
l = set_logger()

current_loc = os.path.split(__file__)[0]
os.environ['DCMDICTPATH'] = current_loc+os.sep+'dicom.dic'
from glob import glob
import dicom
dicom.config.enforce_valid_values = False #required for dealing with invalid tags

from loadsavepars import pars
fields = ('my_aet','local_port','remote_aet','remote_port','remote_signa','exam')
for f in fields:
    exec("%s = pars['%s']"%(f,f))
use_acc = exam

def query(StudyID, ExamID, anonymise=True, path=None):
    """
Execute PACS query on StudyID, ExamID. The resulting output is stored in
'findscu_out', which is what get() uses to fetch data. Uses external
DCMTK executable findscu, see http://dicom.offis.de/dcmtk.php.en

Parameters
----------

StudyID : integer
    Corresponding to the CAD identifier of the patient (as used in the
    old database). [now obsolete and ignored]

ExamID : integer
    Corresponding to the DICOM exam ID, typically five digits long.

anonymise : bool [=True]
    Whether to run anonymising on the fetched query text file.

path : string
    Where to place the resulting DICOM query output.

Returns
-------

a text file is placed in the given directory, no variable is returned.

Example
-------

>>> query(512,12354,path='/home/data/512/12354')
"""
    if os.path.exists('findscu_out'):
         os.remove('findscu_out')
    path = (path or os.getcwd())+os.sep
    cmd = shlex.split('findscu -v -S -k 0009,1002="" -k 0008,1030="" -k 0008,103e="" -k 0010,0010="" -k 0010,0020="" '+\
    '-k 0008,0020="" -k 0020,0010=%i'%(ExamID) + ' -k 0020,0011="" -k 0008,0052="SERIES" ' +\
    '-k 0020,000D="" -k 0020,000e="" -k 0020,1002="" ' +\
    ' -aet ' + my_aet + ' -aec ' + remote_aet + ' ' + remote_signa + ' '+str(remote_port))
    subprocess.call(cmd,stderr=subprocess.STDOUT, stdout=open(path+'findscu_out','w'), cwd=path )
    if anonymise: anon_query(path+'findscu_out')

def anon_query(inlist='findscu_out'):
    """
For the text file output of a PACS query, go through the file removing
patient names (only)

Parameters
----------
inlist : string [='findscu_out']
    Full file name of text file, normally `findscu_out` in the current
    directory.
"""
    try:
        fred = open(inlist)
        lines = fred.readlines()
        fred = open(inlist,'w')
        for line in lines:
            if "(0010,0010)" in line:
                continue
            fred.write(line)
    except IOError:
        pass
    return

def get(inlist='findscu_out', anonymise=True, path=None):
    """
Fetch data from PACS server, using the output of a query in 'findscu_out'
(i.e., all the series of a given exam) or other input list.
Uses external DCMTK executable movescu, see http://dicom.offis.de/dcmtk.php.en

Parameters
----------
inlist : string
    Input file name, normally the one generated by query()

anonymise : bool [=True]
    Whether to remove patient names from the resulting DICOM files

path : string
    The full directory to put the resultant DICOM files into. If not
    specified, used the current directory.
"""
    fred = open(inlist)
    series=None
    seriesUID=None
    instanceUID=None
    path = (path or os.getcwd())+os.sep
    for line in fred:
        try:
            if line[0]=='I': continue
            if "(0020,0011)" in line:
                series = int(line[line.find('[')+1:line.find(']')])
            if "(0020,000e)" in line:
                seriesUID=line[line.find('[')+1:line.find(']')]
            if "(0020,000d)" in line:
                instanceUID=line[line.find('[')+1:line.find(']')]
        except:
            pass
        if series and seriesUID and instanceUID:
            cmd = shlex.split('movescu -S +P '+ str(local_port) +' -k 0008,0052="SERIES" \
            -k 0020,000d=' + instanceUID + ' -k 0020,000e=' + seriesUID +\
            ' -aec ' + remote_aet + ' -aet ' + my_aet + ' -aem ' + my_aet + ' ' + remote_signa + ' ' + str(remote_port))
            subprocess.call(cmd, cwd=path )
            series=None
            seriesUID=None
            instanceUID=None
    if anonymise: anon()

def get_UID(UID, anonymise=True, path=None):
    """
Fetch single series with given series UID (SeriesInstanceUID=0020, 000e).
Calls movescu directly.

Parameters
----------
UID : string
    The DICOM series UID to search for; a dot-seperated sequence of numbers
anonymise : bool [=True]
    Whether to remove patient names from the resulting DICOM files
path : string
    The full directory to put the resultant DICOM files into. If not
    specified, used the current directory.
    """
    part = "-k 0020,000e=%s"%UID
    path = (path or os.getcwd())+os.sep
    cmd = shlex.split('movescu -S +P '+ str(local_port) +' -k 0008,0052="SERIES" '\
            +part+' -aec ' +remote_aet+ ' -aet ' +my_aet+ ' -aem ' +my_aet+ ' ' +remote_signa+ ' ' +str(remote_port))
    print " ".join(cmd)
    subprocess.call(cmd, cwd=path )
    if anonymise: anon(path)

def get_all_patient(patient, **kwargs):
    """
For Patient entity (see sql_run), successively fetch each exam
from PACS. The data will be stored in a directory structure specified
by `form`. Repeatedly calls get_entity() with the exams.

Examples
--------
>>> from prog.fetch_data.sql_run import Session,Patient
>>> s = Session()
>>> pat = s.query(Patient).filter(Patient.pt_id==2).one()
>>> get_all_patient(pat,path='/home/data/pat2/')
    """
    for ex in patient.exams:
        get_entity(ex, **kwargs)

def make_path(exam, scheme=None):
    """
Find where an exam ought to be downloaded to
"""
    from prog.GUI.ui.prefs import schemes
    scheme = scheme or schemes[pars['scheme']]
    bits = scheme.split('/')
    if bits[0]=='patient':
        pat_part = str(exam.pt_id)+os.sep
    else:
        pat_part = exam.patient.cad.cad_pt_no_txt
    if bits[1] == 'accession':
        bit = exam.a_number_txt
    elif bits[1] == 'date':
        bit = str( exam.exam_dt_datetime)
    else:
        bit = exam.exam_img_dicom_txt
    return os.sep.join((pars['datadir'],pat_part,bit))

def get_entity(entity,path=None,scheme=None,skip=True,bg=False):
    """
For the SQL entity (patient, exam or series), fetch the relevant DICOM
data, either ALL of a patient's exams, all the series within one
particular exam, or just one DICOM series. Depending on the entity
given, calls get_all_patient(), get_acession() or get_UID()

Parameters
----------
entity : [Patient, Exam, Series]
    The result of a query on the classes specified in sql_run

path : string
    the directory within which the data tree is to be made.
    Defaults to user parameter.

scheme : string
    How the directories are organised. Should be a "/"-separated list
    of the following [patient,CADpat]/[accession,date,DICOM/]
    and a thuird level (for series) is not yet implemented.
    Defaults to user parameter.

skip : bool
    Ignore datasets where the corresponding directory already
    contains data (per exam)
    
bg : bool
    Run fetch process in the background

Mappings
patient->Patient.pt_id, CADpat->CAD.cad_pt_no_txt,
date->Exam.exam_dt_datetime, accession->Exam.a_number_txt, DICOM->Exam.exam_img_dicom_txt,
series#-> dicom.SeriesNumber, seriesUID->Series.series_uid_txt

Examples
--------
>>> from prog.fetch_data.sql_run import Session,Patient
>>> s = Session()
>>> ser = s.query(Series).filter( Series.pt_mri_series_id ==1).one()
>>> get_entity(ser,'/home/data/','patient/date'):

    """
    if isinstance(entity,sql_run.Patient):
        get_all_patient(entity,path=path,scheme=scheme,skip=skip,bg=bg)
    elif isinstance(entity,sql_run.Series):
        path = make_path(entity.exam)
        uid = entity.series_uid_txt
        get_UID(uid,path=path+os.sep)
    else:
        path = make_path(entity)
        if pars['exam']:
            acc = entity.a_number_txt
            get_acession(acc,use_acc=True,path=path,skip=skip,bg=bg)
        else:
            acc = entity.exam_img_dicom_txt
            get_acession(acc,use_acc=False,path=path,skip=skip,bg=bg)


def get_acession(acc, anonymise=True, path=None,use_acc=True,skip=True,bg=False):
    """
Fetch single exam with accession number (use_acc=True 0008, 0050) or
DICOM exam number (use_acc=False, 0020,0010). Calls movescu directly.

Parameters
----------
acc : integer or string
    The accession number or DICOM number to fetch

anonymise : bool [=True]
    Whether to remove patient names from the resulting DICOM files

path: string
    The directory within which to put the resultant DICOM files. If not
    specified, used the current directory.

use_acc : bool [=True]
    Whether to use the accession number internally in seeking the
    correct data to fetch. Ought to be True because the accession
    should be unique, but in practice False may be more reliable

bg : bool
    Run fetch process in the background
    """
    path = path or os.getcwd()
    if not(os.path.exists(path)):
        os.makedirs(path)
    dicoms = glob(path+os.sep+'*MR*')+glob(path+os.sep+'*dcm')
    if dicoms and skip:
        l.debug('Skipping %s'%acc)
        return
    if use_acc:
        part = "-k 0008,0050=%s"%acc
    else:
        part = "-k 0020,0010=%s"%acc
    l.debug('Fetch: '+part)
    path = (path or os.getcwd())+os.sep
    cmd = shlex.split('movescu -S +P '+ str(local_port) +' -k 0008,0052="SERIES" '\
            +part+' -aec ' +remote_aet+ ' -aet ' +my_aet+ ' -aem ' +my_aet+ ' ' +remote_signa+ ' ' +str(remote_port))
    if bg:
        subprocess.Popen(cmd, cwd=path)
        l.debug('DCMTK launched in background')
    else:
        subprocess.call(cmd, cwd=path)
    if anonymise: anon(path)

def anon(path=""):
    """
For all the DICOM files in the given directory, remove patient
names.

Parameters
----------
path : string
    The full path to work in (default=current directory).

Examples
--------
>>> anon("/home/data/151/21443/")
"""
    allfiles = glob(path+'*MR*')
    for myfile in allfiles:
        try:
            f = dicom.read_file(myfile)
            f.PatientName = "Anon"
            f.save_as(myfile)
        except :
            pass

def recursive_anonymise(path=None):
    """
Descend recursively into a directory structure removing all patient
names from query files (`findscu_out`) and DICOM files, by calling
anon() repeatedly.

Parameters
----------
path : string
    The full path to work in (default=current directory).
"""
    mypath = (path or os.getcwd())+os.sep
    listing = glob(mypath+'*')
    for entry in listing:
        if os.path.isdir(entry):
            recursive_anonymise(entry)
            anon_query(entry+os.sep+'findscu_out')
            anon(entry)

def fetch(studyID,examID, skip_if_q=True,skip_if_d=True, start_path=""):
    """
Access PACS to get data on a given studyID and examID.
The downloaded files will be put into a single directory studyID/examid/
below the current one. This used to be the standard way to retreive
data. Files are automatically stored in studyID/examID/ directories.
Performs query(), then fetch() on the given exam.

Parameters
----------
studyID : int
    The patient number, from the old CAD database (used only to name
    the folder)
examID : int
    the DICOM number to search for
skip_if_q : bool [=True]
    don't redo queries if 'findscu_out' exists.
skip_if_d : bool [=True]
    don't do anything if given directory already contains DICOM files.
start_path : string
    The full path to work in (default=current directory).
    """
    if not(os.path.exists(start_path+os.sep+str(studyID))):
        os.mkdir(start_path+os.sep+str(studyID))
    path = start_path+os.sep+str(studyID)+os.sep+str(examID)+os.sep
    if not(os.path.exists(path)):
        os.mkdir(path)
    if glob(path+'*MR*') and skip_if_d: #Can specifically check for DICOM files?:
        return
    if not(skip_if_q and os.path.exists(path+'findscu_out')):
        query(studyID, examID, anonymise=True, path=path)
    get(path+'findscu_out',anonymise=True, path=path)
